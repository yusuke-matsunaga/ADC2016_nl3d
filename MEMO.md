# nl3d 覚書

<div style="text-align:right;">
松永 裕介
</div>

## はじめに

このプログラムはDAシンポジウム2016アルゴリズムデザインコンテスト用に開発されたものをもとにして
Python3 で書き直したものです．
一部(というか本質的な部分)は省略していますが，
普通の問題ならばこのプログラムで解を求めることができるはずです．


## 問題のルール

W x H マスの長方形を D 枚重ねたものが盤面となります．
各々のマス目は
* 空
* 数字
* アルファベット(最大で２文字)
の内容を持ちます．

同じ数字を持つマス目は必ず２つ存在します．
同じアルファベットを持つマス目は同じX座標とY座標を持ち，
なおかつ，Z座標は連続していなければなりません．

例)
 * (1, 1, 1) (1, 1, 2) (1, 1, 3) が同じアルファベットを持つのはOK
 * (2, 3, 1) (2, 3, 3) は (2, 3, 2) が抜けているのでNG
 * (4, 4, 1) (4, 5, 2) はY座標が異なるのでNG

なお，ファイルフォーマットの仕様上Z座標が昇順になってなければいけないかどうかは
不明です．
あと，何故かX座標とY座標は0から始まりますが，層番号は1から始まります．
私のプログラムでは内部で0から始まる番号に置き換えています．

このパズルの目的は対となった数字のマスの間を結ぶ経路を求めることです．
経路は1つのマスに1本だけ引くことができ，
1つのマス目上で２本の経路が交わることはできません．
要するに，空のマス目に数字を埋めていき，同じ数字のマス目を辿って相方のマス目まで到達できればよい
ということになります．

アルファベットのマス目は層の異なる長方形間を移動するために用いられます．
例えば1番の数字のマス目の一つが1層目にあり，もう一つのマス目が２層にあるときには，
１層目と２層目をつなぐアルファベットのマス目を用いて経路を作る必要があります．
以降，このアルファベットのマス目(の集合)をビアと呼ぶことにします．

一つの経路に対して用いることのできるビアは高々１つです．
また，ADC2016 では未使用のビアはないことになっていますので，
もともと同じ番号の２つのマス目が異なる層に配置されている数字の数と使用されるビアの数は等しいことになります．



## SATソルバを用いた解法

### グラフ問題としての定式化

まず，問題をより数学的に定義するためにグラフ理論の言葉で再定義します．
一つの層を格子グラフと考えます．格子グラフは節点が格子状にならんだグラフで
上下左右の節点間に枝があります．ここでは枝の向きは考えません．
節点はマス目と同様に，
* 自由節点(空)
* 終端節点(数字)
* ビア節点(アルファベット)
の3種類からなります．

1つの層からなる問題の場合，ビアは存在しないので単純に同じ数字の終端節点を結ぶ素な経路を求める問題となります．
複数の層からなる問題の場合，まず各数字とビアの割り当てを行うことを考えます．
すると個々の層ごとに独立した問題となりますのでそれを個々に解けばよいことになります．
もっともこのやり方では多層にまたがる線分数の階乗に比例した割り当て方があるので
そのままでは実用的ではありません．


### SAT問題へのエンコーディング(単層)

まず単層問題を考えます．
最終結果は各節点が何番の経路として使われるか(あるいは使われないか)，
ということですが，そうすると場合の数は (線分数 + 1)^(節点数) となり莫大な
探索空間となります．
答が素な経路であることに着目して，経路として用いられる枝の集合で答を表すことを
考えると，探索空間は 2^(枝数) となります．
今までの経験上，このエンコーディングがもっともシンプルかつ効率的と思われます．

ただし，これだけでは同じ数字同士が一つの経路で結ばれていることを表すのが難しいので
補助的に各節点が何番の経路として用いられているかを表す変数を導入します．
つまり，結局は最初と同じように別途(線分数 + 1)^(接点数)の探索空間が必要となります．
ただし，枝に対応する変数を設けたことによってさまざまな制約を効率よく表すことが
できます．
さらに，この線分番号を表すやり方が通常の２進符号方式とone-hot符号方式の２通りが
考えられます．明らかに線分数が多いときにはone-hot方式は不利ですが，
制約が簡潔に書けるという利点があります．
私はone-hot方式のほうが有利だと考えています．


### 多層問題への拡張

考え方としては前述のように，まずビアと線分の割り当てを考え，
各層ごとの配線問題に落としたあとで個別に解くという方針を取ります．
実際には個々の割り当てを明示的に列挙するのは効率が悪いので，
割り当てを表す変数を用意してその変数の割り当てまで含めて一気にSATで解くやり方を用います．
単純には線分とビアの組み合わせに対して１つの論理変数を用意し，
線分iとビアjが結ばれる時1になるようにすれば良いことになります．
実際には，層の関係で決して使われることのない線分とビアの関係があるので，
そこを考慮すると必要な変数の数を減らすことができますが，ここの実装では
単純にすべての線分とすべてのビアの割当を考えています．

すこし注意が必要なのがスルービアです．
これはその上下の層に終端とつながったビアがあるが，
自分自身はどことも接続しないビアのことです．
この場合，この節点にはラベルを振らないようにする必要があります．


### ２進符号方式の詳細

２進符号方式の場合には一つのノードにつき log2(ラベル数 + 1) ビットの変数を用意します．
経路に用いられない場合には 0 のラベル値を使います．
枝 e で隣接している２つのノード n1 と n2 のラベルに関する制約は以下の通りとなります．
* e が選ばれているとき n1 と n2 のラベルは等しい．
2つのラベルが等しい時は各ビットごとに独立に e -> n1 = n2 のCNF式を作ります．
ただ，現時点では後述の one-hot 方式のほうが効率的のようである．


### one-hot 方式の詳細

one-hot 方式の場合には一つのノードにつきラベル数の変数を用意します．
大まかには one-hot と呼んでいますが，実際には all-0 の場合もあります．
隣接するノード間の制約は２進符号方式とほぼ同様です．
具体的には
* e -> n1 = n2 これは各ビット独立
ラベル数が多くなると変数の数が増える欠点があるが，
扱える範囲内であればこちらの方式のほうが効率がよい．


### 解の出力

SATソルバが SAT と答えたときはすべての変数に対する真偽の割当が決まったモデルが
返されます(現状の多くのSATソルバはすべての変数割当を行ったモデルを返します)．
そこから解を作るには単純には各マス目の線分番号をそのまま取り出せばよいように思われますが，
これには落とし穴があります．
実は上に述べた制約では，終端とまったく繋がっていない領域にラベルがつくことを禁止できません．
ですので，孤立したループ状の経路が残っている場合があります．
そこで，SATの解(モデル)から実際の解を得るには終端節点から選ばれている枝をたどっていき，
その経路上の節点のみ線分番号をつけるという処理を行います．
実際には，ここでより経路長の短い経路を求めたりするヒューリスティックも考えられます．
いろいろと工夫の考えられるポイントだと思います．


### 性能改善のためのヒューリスティック

上のエンコーディングを用いてCNF式を作りSATソルバで解いてもそこそこのものができるが，
実はあまりうまくは行きません．そこでいくつかのヒューリスティックが提案されています．


#### 全マス使用制約

これはオリジナルのナンバーリンク問題が課している暗黙の制約みたいなもので，
すべてのマスがいずれかの経路に用いられると言う制約です．
ナンバーリンクのルールにはそんなことは一言も書いていないし，
アルゴリズムデザインコンテストでは意図的に全マスを使用しない問題が出されているので，
この制約を加えて問題を解くと本当は答があるのに答なしという誤った解を出すことに
なります，
実際に全マスを使う問題に対しては圧倒的なスピードアップとなります．
全マスを使う解がない問題に対してもすぐにUNSATをわかることが多いので，
最初にこの制約付きでトライしてみてUNSATの時に次のヒューリスティックを試すのが
効果的だと思われます．


#### U字制約

コの字，ロの字とも言いいます．

~~~
 o --- o
 |     |
 |     |
 o --- o
~~~

の３辺の枝は同時に使われないという制約です．これはほぼ完全な制約で，
この制約を満たさない解は存在しますが，その場合，残りの１辺のみを使った制約充足解も
必ず存在するので入れておいて損はない制約だと思います．


#### W字制約

~~~
 o -B- o -C- o
 |     |     |
 A           D
 |     |     |
 o --- x --- o
~~~

の形で，x が終端やビアでないときには A, B, C, D が同時に選ばれないという制約である．
これもほぼ完全な制約なので常に入れておきます．


### 戦略

以下の順に試します．
* 全マス制約 + U字制約 + W字制約
* U字制約 + W字制約

だいたいUNSATの場合には数秒でわかるのできつい制約から先に試します．

実際にはこれ以外にもいくつかの制約が考えられています．
逆にいうとSATソルバを用いたナンバーリングソルバの性能はここで決まるので
いろいろと工夫してみるとよいでしょう．


### プログラムについて

今回，上記の説明にしたがったプログラムを Python3 用に作りました．
ディレクトリ・ファイル構成は以下の通りです．
SATソルバは外部プログラムの minisat_static を呼び出して使います．
cython などで内部で SATソルバを起動することも可能です．
ただ，今回は1つの問題に対して数回起動するだけなので外部プログラム
を起動する形でもそれほどオーバーヘッドは問題にならないと思われます．

#### 概略

```
nl3d/__init__.py :      パッケージ用のファイル
     adc2016_reader.py: 問題と解答ファイルのパーサー
     nlcnfencoder.py:   SATのCNF式を作るクラス
     nlgraph.py:        問題を表すグラフのクラス
     nlpoint.py:        座標を表すクラス
     nlproblem.py:      問題を表すクラス
     nlsolution.py:     解を表すクラス
     nlsolver.py:       ソルバプログラム
     nlvia.py:          ビアを表すクラス
     sat/__init__.py:   パッケージ用のファイル
         satbool3.py:   3値を表すクラス
	 satsolver.py:  SATソルバのクラス(外部プログラムを呼び出すバージョン)
	 satsolver_tmpl.py: 別の実装用のインターフェイスのテンプレート
     gui/__init_.py:    パッケージ用のファイル
         nlviewmgr.py:  問題と解答を表示するウィジェットを管理するクラス
	 nlviewwidget.py: 問題と解答の1つの層を表示するウィジェットクラス
```

このファイルを Python インタプリタの検索パスに入れて
```
import nl3d
```
とすればこの中のクラスが使えるようになります．


#### ファイル入出力と基本データ構造

ファイルの読み込みは nl3d.Adc2016Reader で行います．
```
reader = nl3d.Adc2016Reader()
problem = reader.read_problem(fin1)
solution = reader.read_solution(fin2)
```
の様に用います．ここで fin1, fin2 はファイルオブジェクトです．
問題は nl3d.NlProblem の形で返されます．
解答は nl3d.NlSolution の形で返されます．
実際には問題を扱いやすくするために nl3d.NlGraph
というクラスに変換します．
これは
```
graph = nl3d.NlGraph(problem)
```
で行います．
NlGraph は問題のサイズと線分数，ビアの情報と
各マス目に対応した節点(nl3d.NlNode)のリスト
および枝(nl3d.NlEdge)のリストを持ちます．


#### SAT制約の生成と求解

nl3d.NlCnfEncoder がメインの仕事をするクラスです．
ここでは各枝と各節点に対応するSAT問題用の変数を
割り当て，さまざまな制約を生成します．
枝と節点に関する基本的な制約は
```
nl3d.NlCnfEncoder.make_base_constraint(no_slack)
```
で生成します．no_slack はブール変数で True のときは
全マスを使う制約を付加します．

U字制約およびW字制約は
```
nl3d.NlCnfEncoder.make_ushape_constraint()
nled.NlCnfEncoder.make_wshape_constraint()
```
で生成します．
実は make_w2shape_constraint() というのもあります．

制約の生成が終わったら nl3d.sat.SatSolver.solve() でSAT問題を解きます．
充足解が得られたら．
```
solution = nl3d.NlCnfEncoder.model_to_solution(model)
```
で解(nl3d.NlSolution)を得ます．

プログラムの詳細はプログラム内部のコメントを参照してください．
また，(Pythonではあまりやられていないようですが)コメントの先頭に Doxygen
用のタグを仕込んでいます．
'dox' ディレクトリの下で doxygen を起動するとファイル一覧，クラス一覧などの
ドキュメントが生成されます．


#### GUI プログラム

問題と解の確認用に PyQt5 を用いた GUI プログラムも付けています．
nl3d.gui.NlViewWidget がメインのウィジェットでナンバーリンクの問題と解の
1つの層を表示するウィジェットです．
nl3d.gui.NlViewMgr は複数の層のウィジェットを管理するためのクラスで，
問題や解の設定はこちらのクラスを用いて行います．
使っていませんが，シグナルの設定も行っています．


### テストプログラム

簡単なテストプログラムが tests 以下にあります．
内容はプログラムのコードを読めばわかると思います．
各クラスの使い方の参考にしてください．
